## 주소 바인딩이란?

주소 바인딩이란 프로세스의 논리적 주소를 물리적 주소로 연결시켜주는 작업을 주소 바인딩이라고 한다.

![주소 바인딩](/img/computer_architecture_and_OS/address_binding/address_binding.png)

:::info
주소 프로그램이 실행되는 동안 CPU에 의해 생성 된 것을 논리적 주소라고 한다. 논리 주소는 물리적으로 존재하지 않으므로 가상 주소이다. 따라서 가상 주소 라고도한다. 이 주소는 실제 메모리 위치를 액세스하기위한 참조로 사용된다. 프로그램 관점에서 생성 된 모든 논리 주소 집합을 논리 주소 공간 이라고한다.
:::

주소 바인딩이 되는 시점은 크게 세가지가 있는데 다음과 같다.

- 컴파일 시점 주소 바인딩
- 로드 시점 주소 바인딩
- 실행 시점 주소 바인딩

이 세가지에 대해서 자세하게 알아보도록 하자.

## 컴파일 시점 주소 바인딩

이 방식은 컴파일을 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인가를 결정하는 방식이다.

여기서는 컴파일을 하는 시점에 명령어들과 변수의 메모리 주소가 정해지므로 **논리적 주소와 물리적 주소가 같다는 특징**을 갖고 있다.

프로그램에 절대 주소가 포함되어 있어서 프로세스를 로드하는 것이 빠르지만, 생성된 주소 공간이 다른 프로세스에 의해 점유되어 있을 경우 충돌할 수 있어서 다시 컴파일을 해야 하는 경우가 발생한다. 이러한 이유 때문에 다중 프로그래밍이 가능한 현대 OS환경에서는 사용되지 않는 방법이다.

![컴파일 시점 바인딩](/img/computer_architecture_and_OS/address_binding/compile_binding.png)

## 로드 시점 주소 바인딩

로드 시점 주소 바인딩은 프로그램이 컴파일 되고 메모리에 올라갈 때 CPU에서 주소 계산이 일어난다.

로더에 의해 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 메모리 상의 위치가 고정된다.

컴파일러가 **재배치 가능 코드**를 생성한 경우에 가능한 주소 바인딩이다.

프로그램 속의 코드 세그먼트를 모두 바꿔줘야 하므로 메모리 로딩할 때 오랜 시간이 소요된다.

컴파일 시점 주소바인딩과 비교하자면 시작 주소가 바뀌었을 때 컴파일 방식은 리컴파일을 해줘야 하지만 로드 시점 주소 바인딩은 리로드만 해주면 된다.

:::info
재배치 가능 코드 : 재배치 가능 코드란 기준 위치 주소를 사용하는 코드를 말한다.
:::

![로드 시점 바인딩](/img/computer_architecture_and_OS/address_binding/loadtime_binding.png)

## 실행 시점 주소 바인딩

실행 시점 주소 바인딩이란 실행 시간에 논리 주소를 물리 주소로 바인딩하는 것을 말한다.

현대 OS는 대부분 이 방식을 사용하고 한 메모리 세그먼트에서 다른 메모리 세그먼트로 실행 중에 이동하는 것이 가능하려면 런타임까지 바인딩을 지연 시켜야 한다.

일반적으로 이 방식은 MMU 하드웨어를 사용하여 논리적 주소에서 물리적 주소로 매핑하게 된다.

cpu에서 발생한 주소가 논리적 주소이고 MMU를 통해 바뀐 주소가 메모리의 실제 주소인 물리주소이므로 실행 시점 주소 바인딩에서는 두 주소가 다르다.

![실행 시점 바인딩](/img/computer_architecture_and_OS/address_binding/mmu_binding.png)

## 번외) MMU기법

MMU란 Memory Management Unit의 약자로 논리적 주소를 물리적 주소로 매핑해주는 하드웨어이다.

CPU에서 생성된 모든 logical address 에 대해서 주소가 메모리에 넘겨질 때마다, 기준 주소값을 더해준다.

추가적으로 실행 시점 주소 바인딩에 사용하는 MMU 하드웨어 기법은 다음과 같은 과정으로 진행된다.

1. CPU가 논리적 주소 123번지에 있는 내용을 요청한다.
2. 재배치 레지스터에 저장된 값 23000을 더한다.
3. 물리적 메모리에 23123에 저장한다.

이 방식에는 한가지 문제점이 있는데 바로 MMU 방식을 사용하여 주소 변환을 하였을 때 물리적 메모리 영역을 벗어날 수 있다.

이를 보완하기 위한 방법은 다음과 같다.

1. CPU가 요청한 프로세스의 **논리적 주소 값 < 한계 레지스터 내에 저장된 프로세스의 크기**인지 확인한다.
2. 크기가 작다면 논리적 주소 값에 재배치 레지스터 값을 더해 물리적 주소를 구하여 메모리 위치를 접근하도록 허락한다.
3. 크기가 더 크다면 트랩을 발생시켜 해당 프로세스를 강제 종료한다.

## 참고 url

- [메모리 관리 1 - 주소 바인딩 - 티스토리 블로그](https://gamedevlog.tistory.com/83)
- [주소 바인딩에 대해서 - 티스토리 블로그](https://beyndlevel.tistory.com/35)
- [운영체제 - Memory-1 - 티스토리 블로그](https://baked-corn.tistory.com/15)
- [메모리관리 주소바인딩 - 티스토리 블로그](https://junyng.tistory.com/46)

## 기여자

<td align="center"><a href="http://kyun2da.dev"><img src="https://avatars.githubusercontent.com/u/50328132?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Kyun Heo</b></sub></a><br /><a href="#platform-Kyun2da" title="Packaging/porting to new platform">📦</a></td>
